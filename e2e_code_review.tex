\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage[all]{xy}


\usepackage{amsmath,amsthm,amssymb,color,latexsym}
\usepackage{geometry}
\usepackage{physics}
\usepackage{mathtools}
\geometry{letterpaper}    
\usepackage{graphicx}
\usepackage{nicefrac}
\usepackage{enumitem}
\usepackage{minted}
\newcommand{\pmint}[1]{\mintinline{Python}{#1}}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    urlcolor=cyan,
    }

\begin{document}
\noindent e2e Notes \hfill Andres Covarrubias    \\
5/17/22

\hrulefill
\section*{Imports (Lines 1-22)}
\subsection*{\href{https://pymatgen.org/}{pymatgen}}
A robust, open-source Python library for materials analysis.

    \subsubsection*{\href{https://pymatgen.org/pymatgen.io.vasp.html?highlight=io\%20vasp\#module-pymatgen.io.vasp}{pymatgen.io.vasp}} Implements modules for input and output to and from VASP. See VASP to QE table for more information. 
    
    \subsubsection*{\href{https://pymatgen.org/pymatgen.core.html}{pymatgen.core}} A package containing core modules and classes for representing structures and operations on them. The first import is the \href{https://pymatgen.org/pymatgen.core.structure.html?highlight=structure#module-pymatgen.core.structure}{Structure} module which provides classes used to define a non-periodic molecule and a periodic structure. The second import is \href{https://pymatgen.org/pymatgen.core.periodic_table.html?highlight=element#pymatgen.core.periodic_table.Element}{periodic\textunderscore table.Element} which is an \href{https://docs.python.org/3/library/enum.html}{enum} which represents an element in the periodic table. 
    
    \subsubsection*{\href{https://pymatgen.org/pymatgen.analysis.magnetism.analyzer.html}{pymatgen.analysis.magnetism.analyzer}} A module which provides some useful functions for dealing with magnetic Structures. The first import is  \href{https://pymatgen.org/pymatgen.analysis.magnetism.analyzer.html?highlight=magneticstructureenumerator#pymatgen.analysis.magnetism.analyzer.MagneticStructureEnumerator}{MagneticStructureEnumerator} which will automatically generate a set of transformations for a given structure and produce a list of plausible magnetic orderings. The second import is \href{https://pymatgen.org/pymatgen.analysis.magnetism.analyzer.html?highlight=collinearmagneticstructureanalyzer#pymatgen.analysis.magnetism.analyzer.CollinearMagneticStructureAnalyzer}{CollinearMagneticStructureAnalyzer} which provides a few helpful methods to analyze collinear magnetic structures.

\subsection*{\href{https://docs.python.org/3/library/sys.html}{sys}}
Built in module which provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.

\subsection*{\href{https://docs.python.org/3/library/os.html}{os}}
Built in module which provides a portable way of using operating system dependent functionality.

\subsection*{\href{https://docs.python.org/3/library/shutil.html}{shutil}}
Built in module which offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. Specifically imports \href{https://docs.python.org/3/library/shutil.html?highlight=copyfile#shutil.copyfile}{copyfile}, which copies a file from a source path to a destination path. 

\subsection*{\href{https://docs.python.org/3/library/subprocess.html}{subprocess}}
Built in module which allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. Specifically imports \href{https://docs.python.org/3/library/subprocess.html?highlight=popen\#subprocess.Popen}{Popen} which executes a child program in a new process.

\subsection*{\href{https://docs.python.org/3/library/datetime.html}{datetime}}
Built in module which supplies classes for manipulating dates and times.

\subsection*{\href{https://docs.python.org/3/library/time.html}{time}}
Built in module which provides various time-related functions. The first import is \href{https://docs.python.org/3/library/time.html#time.time}{time} which returns the time in seconds since the epoch as a floating point number. The second import is \href{https://docs.python.org/3/library/time.html#time.sleep}{sleep} which suspends execution of the calling thread for the given number of seconds. 

\subsection*{\href{https://wiki.fysik.dtu.dk/ase/}{ase}}
The Atomic Simulation Environment (ASE) is a set of tools and Python modules for setting up, manipulating, running, visualizing and analyzing atomistic simulations. The code is freely available under the GNU LGPL license.

    \subsubsection*{\href{https://wiki.fysik.dtu.dk/ase/ase/io/io.html\#module-ase.io}{ase.io}}
    ASE module which handles file i/o Specifically imports \href{https://wiki.fysik.dtu.dk/ase/ase/io/io.html#ase.io.read}{read} and \href{https://wiki.fysik.dtu.dk/ase/ase/io/io.html#ase.io.write}{write}. Compatible with both QE and VASP. 
    
    \subsubsection*{\href{https://wiki.fysik.dtu.dk/ase/ase/build/build.html?highlight=build\#module-ase.build}{ase.build}}
    ASE module for creating molecular structures. The first import is \href{https://wiki.fysik.dtu.dk/ase/ase/build/tools.html?highlight=make_supercell#ase.build.make_supercell}{make\textunderscore supercell} which generates a supercell by applying a general transformation to the input configuration. The second import is \href{https://wiki.fysik.dtu.dk/ase/ase/build/tools.html?highlight=sort#ase.build.sort}{sort} which returns a new Atoms object with sorted atomic order.

\subsection*{\href{https://numpy.org/doc/stable/}{numpy}}
A Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.

\subsection*{\href{https://docs.sympy.org/latest/index.html}{sympy}}
A Python library for symbolic mathematics. The first import is \href{https://docs.sympy.org/latest/modules/core.html?highlight=symbol#module-sympy.core.symbol}{Symbol} which is a class facilitates symbolic calculations in Python. The second import is \href{https://docs.sympy.org/latest/modules/solvers/solveset.html?highlight=linsolve#sympy.solvers.solveset.linsolve}{linsolve} which solves a system of $N$ linear equations with $M$ variables

\subsection*{\href{https://docs.python.org/3/library/itertools.html}{itertools}}
Built in module which implements a number of iterator building blocks. Specifically imports \href{https://docs.python.org/3/library/itertools.html#itertools.combinations}{combinations} which returns a variable length subsequence of elements from an iterable input. 

\subsection*{\href{https://docs.python.org/3/library/math.html}{math}}
Built in module which provides access to the mathematical functions defined by the C standard.

\subsection*{\href{https://numba.readthedocs.io/en/stable/index.html}{numba}}
A just-in-time (jit) compiler for Python. Works best on code that uses NumPy arrays, functions, and loops. The first import is \href{https://numba.pydata.org/numba-doc/latest/user/jit.html}{jit} which is a decorator that flags a function for jit compilation. The second import is \href{https://numba.pydata.org/numba-doc/latest/cuda/index.html}{cuda} which extends jit to GPU compilation. Need to install the cudatoolkit in order to use. 

\subsection*{\href{https://docs.python.org/3/library/pickle.html}{pickle}}
Built in module which implements binary protocols for serializing and de-serializing a Python object structure. The first import is \href{https://docs.python.org/3/library/pickle.html?highlight=load#pickle.load}{load} which reads the pickled representation of an object from an open file object and returns the reconstituted object hierarchy specified therein. The second import is \href{https://docs.python.org/3/library/pickle.html?highlight=load#pickle.dump}{dump} which writes the pickled representation of an object to an open file object. 

\section*{Setting parameters and input parsing (Lines 29-93)}
Sets up default values for variables usually defined with the input file. Input parsing set up to read a set of key-value pairs from the input file. 
\section*{Function Definitions (Lines 98-270)}
\subsection*{Pre-Defined Functions}
\begin{itemize}
    \item \mintinline{Python}{replaceText(fileName,toFind,replaceWith)} 
    
    
    Opens and reads \mintinline{Python}{fileName}, replaces \mintinline{Python}{toFind} with \mintinline{Python}{replaceWith}, then re-writes the file with the new text. 
    
    \item \mintinline{Python}{writeLog(string)} 
    
    Appends \mintinline{Python}{string} to the log along with the \mintinline{Python}{datetime}
    
    \item \mintinline{Python}{dist_neighbors(struct)}
    
    Calculates, logs, and returns the distances of neighboring atoms in \mintinline{Python}{struct}. 
    
    \item \mintinline{Python}{Nfinder(struct_mag,site,d_N,dr)}
    
    Finds and returns the coordinates of both \mintinline{Python}{site} and all the neighbors within \mintinline{Python}{d_N-dr} and \mintinline{Python}{d_N+dr}. Used to find the $N$ nearest neighbors to a site. 
    
    \item \mintinline{Python}{my_kernel(all_coords,coord_N,index)}
    
    Sets up kernel for GPU processing
    
    \item \mintinline{Python}{NfinderGPU(struc_mag,site, d_N, dr)}
    
    \mintinline{Python}{Nfinder} optimized for GPU processing
    
    \item \mintinline{Python}{find_max_len(lst)}
    
    Calculates and returns the max length of \mintinline{Python}{lst}
    
    \item \mintinline{Python}{make_homogenous(lst)}
    
    Standardizes lists, important for neighbor mapping
    \item \mintinline{Python}{tFunc(spin_abs,spin_x,spin_y,spin_z,mags,magsqs,T,J2flag,J3flag,J4flag,J5flag)}
    
    Monte-Carlo Algorithm for approximating $T_c$ with JIT compilation. See section on monte-carlo simulation for more details. 
\end{itemize}

\section*{Generating magnetic spin configurations (Lines 292-318)} %%% Spin Config Generation %%%
Reads the cell from the given struct and then uses the \mintinline{Python}{MagneticStructureEnumerator} method from Pymatgen to generate symmetry valid spin configurations. These configurations are then screened to see if they are 2D. If only 1 valid configuration is found, the code exits. 

\section*{Auxiliary dictionaries (Lines 328-368)} %%% Aux Dicts %%% 

First there is a list of magnetic elements and their abbreviation on the periodic table. 

Second there is a dictionary with key-value pairs corresponding to specifies the strength of the effective on-site exchange interactions, $J$,  for using the DFT+U approach (LDAUJ). All $J$ values are set to $0$ by default, and is updated here if a value was given in the input file. 

Third there is a dictionary with key-value pairs corresponding to specifies the strength of the effective on-site Coulomb interactions, $U$,  for using the DFT+U approach (LDAUU). Default values where data mined from the Materials Project, but are updated here if a value was given in the input file.

Fourth there is a dictionary with key-value pairs corresponding to specifies the $l$-quantum number for which the on-site interaction is added  for using the DFT+U approach (LDAUL). All $l$ values are set to $2$ by default, and are updated here if a value was given in the input file.

There are three more dictionaries: \pmint{relax_dict}, \pmint{stat_dict}, and \pmint{mae_dict}. These contain key-value pairs for default values needed for DFT calculations in VASP. Additionally, here is where values are changed if the accuracy is set to high. 

\section*{Relaxation DFT Calculations (372-496) } %%% Relax DFT %%%

Calculates that magnetization of a particular structure, then filters out configurations that either are Ferrimagnetic or have uneven spins. Then uses the \pmint{MPRelaxSet} method from Pymatgen to generate input files for VASP. These input files are then submitted to VASP and a relaxation calculation is done. If the calculation doesn't converge, troubleshooting is done automatically for a couple common fixes (change NSIM $\rightarrow$ reducing POTIM $\rightarrow$ increasing  SYMPREC $\rightarrow$ Turning off symmetry)


% (change NSIM $\rightarrow$ Linear Mixing $\rightarrow$ increasing  SYMPREC $\rightarrow$ Turning off symmetry)

\section*{Static DFT Calculations (Lines 498-625)} %%% Static DFT %%%

\section*{MAE Calculations (Lines 628-817) } %%% Non-collinear MAE DFT %%%

\section*{Hamiltonian Fitting (Lines 820-1219)} %%% Hamiltonian Fitting %%%

Fits the \href{https://en.wikipedia.org/wiki/Quantum_Heisenberg_model}{Heisenberg Hamiltonian} 
\begin{align*}
    H &= -\frac{1}{2}\sum_{\langle i,j\rangle } J_1\textbf{S}_i\textbf{S}_j-\frac{1}{2}\sum_{\langle i,l\rangle} J_2\textbf{S}_i\textbf{S}_l-\frac{1}{2}\sum_{\langle i,m\rangle} J_3\textbf{S}_i\textbf{S}_m-\frac{1}{2}\sum_{\langle i,n\rangle} J_4\textbf{S}_i\textbf{S}_n \\
    &- \sum_i\Big[ k_xS_{ix}^2 - k_y S_{iy}^2- k_z S_{iz}^2\Big]
\end{align*}
 
\section*{Neighbor Mapping (Lines 1271-1495)} %%% Neighbor Mapping %%%
Begins by checking if an input file for the MC simulation was included in the directory. If the file already exists, the previously calculated neighbors lists are unpickled and the following steps are skipped. 

If not, the code will write an input file for the MC simulation with the coupling constants, EMA, MAE values, start and end temps, and magnetic moment per atom. Then proceeds to parse the input file and create a new directory to hold the data from the MC calculation. Proceeds to call \pmint{CollinearMagneticStructureAnalyzer} and creates a $50 \times 50 \times 1$ super cell where only the magnetic atoms of the structure are present. Next, the code records the Cartesian coordinates of each of the sites in the structure, casts the list into a numPY array, then flattens the array. Lastly, creates 5 dummy lists of lists for each of the nearest neighbor sites. 

Checks if \pmint{GPU_accel} is enabled, and uses the appropriate \pmint{Nfinder}. Note that if \pmint{GPU_accel} is not enabled, the mapping will be done sequentially rather than in parallel, which has the potential to be significantly slower. 

Lastly the neighbor mapping is done. There is a for loop which iterates over the elements of the dummy lists, and overwrites the entries with calls to the appropriate \pmint{Nfinder}. The amount of lists iterated over corresponds to the number of coupling constants which were found in the Hamiltonian fitting. If \pmint{more_than_2_metal_layers} is set to true in the input file, then the code proceeds to call \pmint{make_homogeneous} on each of the lists. Finally the code pickles the lists for future use. 


\section*{Monte-Carlo Simulation (Lines 1497-1526)} %%% MC calcs %%%
First creates a range of temperatures as defined in the input MC file written in the neighbor mapping section. For each temperature in that range, the following monte-carlo simulation takes place. Dummy arrays are created for the spin in each Cartesian direction, the absolute spin, the magnetization, and the magnetic susceptibility. Then calls \pmint{tFunc}
\subsection*{tFunc}
Picks a random site from the list of nearest neighbor sites, and records the spin of that site. Then rotates the spin by two random angles and records the spin. Then calculates the energy difference of the system before and after the spin was rotated. If the energy of the system decreased, the new spin is kept. If the energy of the system increases or stays the same, then another random number, $\mathrm{samp}$, is generated. If $\mathrm{samp}$ satisfies
\begin{equation*}
    \mathrm{samp} \leq e^{-\nicefrac{\Delta E}{k_B T}}
\end{equation*}
then the spin is still updated. If not, then nothing happens, and another spin is chosen randomly. This process continues for $10^4$ steps, then an additional loop is added to calculate the magnetism and magnetic susceptibility of the system. For each step until $10^5$ steps are taken, these values are calculated and recorded. The function finally returns the average of both calculated values. 

Once the \pmint{tFunc} call finishes the temperature, magnetization, and magnetic susceptibility are printed and logged. Analysing this for all temperatures will divulge the Curie Temperature. 

\section*{Personal Notes}
\begin{itemize}
    \item Maybe replace instances of range(len()) in function definitions?
    \item \mintinline{Python}{get_cell_lengths_and_angles()} in line 293 is deprecated and needs to be replaced. See \href{https://wiki.fysik.dtu.dk/ase/releasenotes.html}{here}, suggests replacing with \mintinline{Python}{atoms.cell.cellpar()}
    \item Figure out how to reuse / replace \pmint{relax_dict}, \pmint{stat_dict}, and \pmint{mae_dict} for building QE input files. 
    \item See if input VASP files can be converted to QE files at line 410 (post MPRelax calls)
    \item Need to re-write lines 411-496 to fit with QE file I/O
\end{itemize}
\end{document}
